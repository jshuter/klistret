#labels Phase-Support,Perl,Client
Perl can be a simple language to execute HTTP calls and process JSON responses.

= Introduction =
The contents of this article is geared to users of Perl on Unix like systems but the gist regarding programming as a client work for Perl on Windows.

= Perl Installation =
[http://www.perl.org/get.html Download] Perl to a pack-up directory then following the steps below pointing the actual installation to another directory:
{{{
  cd <unpacking directory>
  gunzip perl-<version>.tar.gz
  tar xvf perl-<version>.tar
  cd perl-<version>
  export PATH=$PATH:/usr/ccs/bin
  sh Configure -de -Dprefix='<installation directory' -Dcc=gcc
  make
  make install
}}}

== HTTP Tiny ==
Communication to Klistret goes through HTTP GET/PUT/POST/DELETE calls and an easy way is to use [http://www.dagolden.com/index.php/1212/why-httptiny HTTP Tiny].  Installing modules is easy if you have a Perl installation that can be modified (otherwise the "--prefix" argument is a must).  HTTP Tiny is included in at least Perl 5.14.

== JSON ==
A standard data format is JSON and one of the better modules is [https://metacpan.org/module/JSON JSON] which requires [https://metacpan.org/module/JSON::XS JSON-XS] and something called [https://metacpan.org/module/common::sense Common Sense].

== CGI ==
The last piece of the basic puzzle is [https://metacpan.org/module/CGI CGI] which is helpful for encoding URLs (especially query strings).  Escaping query strings is necessary.  A good online tool to check encoding is [http://coderstoolbox.net/string a String converter].

= Finding stuff =
Searching after CI in Klistret is a matter of filtering with XPath statements.  For example, the following series of XPath expressions will pull back software belongs to a particular module and version:
{{{
  1) declare namespace pojo="http://www.klistret.com/cmdb/ci/pojo"; /pojo:Element[empty(pojo:toTimeStamp)]/pojo:type[pojo:name eq "{http://www.klistret.com/cmdb/ci/element/component}Software"]

  2) declare namespace pojo="http://www.klistret.com/cmdb/ci/pojo"; /pojo:Element[pojo:name = ("INF")]

  3) declare namespace pojo="http://www.klistret.com/cmdb/ci/pojo"; declare namespace component="http://www.klistret.com/cmdb/ci/element/component"; /pojo:Element/pojo:configuration[component:Version eq "0068_A01"]
}}}

Every CI is either an Element or Relation class.  It is recommended that users try to return a specific type of CI which is what the first XPath expression does.  It specifies that the CI must be active [_toTimeStamp_ is null] and that the CI type is _Software_.  The module name is the same as the name property for Software as filtered in the second expression.  The last expression weans the search down to a version called 0068_A01.

== Writing queries in Perl ==
There is more information about how to formulate a XPath expression on the CI pages.  But what about writing a series of filters in Perl?  The first thing to do is setup the necessary modules and the URL to Klistret:
{{{
  use HTTP::Tiny;
  use Encode;
  use CGI;
  use JSON;

  use strict;
  use warnings;

  ##############################################################
  # URL to Element service
  ##############################################################
  my $findService = 'http://<dns + port>/CMDB/resteasy/element?start=0&limit=20';

  # Expression clauses
  my $expressionClause = '&expressions=';
}}}

The *start* and *limit* variables in the query string tell Klistret to pull the very first database record up to 20 records thereafter.  So *limit* is the number of records to return while *start* is the starting record.

Transforming the sample expressions to a couple Perl scalars is pie outside of setting a useful name:
{{{
  ##############################################################
  # Filters
  ##############################################################
  my $typeAndActiveFilter = 'declare namespace pojo="http://www.klistret.com/cmdb/ci/pojo"; /pojo:Element[empty(pojo:toTimeStamp)]/pojo:type[pojo:name eq "{http://www.klistret.com/cmdb/ci/element/component}Software"]';

  my $moduleFilter = 'declare namespace pojo="http://www.klistret.com/cmdb/ci/pojo"; /pojo:Element[pojo:name = ("INF")]';

  my $versionFilter = 'declare namespace pojo="http://www.klistret.com/cmdb/ci/pojo"; declare namespace component="http://www.klistret.com/cmdb/ci/element/component"; /pojo:Element/pojo:configuration[component:Version eq "0068_A01"]';

  ##############################################################
  # Complete request
  ##############################################################
  my $request = $findService . $expressionClause . CGI::escape($typeAndActiveFilter) . $expressionClause . CGI::escape($moduleFilter) . $expressionClause . CGI::escape(versionFilter);
}}}

Now we have a request in the form of a REST URL.  Each filter is appended to the query string as the variable _expressions_.  Only the filter strings need to be escaped.  The next step is to use HTTP Tiny to fire off the request and process the results:
{{{
  ##############################################################
  # Do HTTP Get
  ##############################################################
  my $response = HTTP::Tiny->new->request('GET', $request , {
    'headers' => { 'Accept' => 'application/json' }
  });
}}}

The options of the Tiny request force Klistret to return JSON data.  The response has set of constructs that get hashed into the _response_ variable.  The *success* is a Boolean flagging a positive return or not.  *Content* is another keeper since it holds the actual data payload:
{{{
  
}}} 